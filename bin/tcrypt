#!/bin/bash

APPVER="v0.1.4-pre1"

function debug() {
    printf ""
    echo ">>> debug: $1"
}

CONFDIR="$HOME/.config/tcrypt"
mkdir -p "$CONFDIR"/{mykeys,}
### CSV delimiter is whitespace
touch "$CONFDIR/contacts.csv"
touch "$CONFDIR/known_signers.csv"     ### CSV format: "{NAME} ssh-ed25519 {SSHPUBKEY} {COUNT}"

export tcrypt="$(realpath $0)"
export TCryptSession="/tmp/tcryptUtilSession-$(uuidgen v4)"

export FULLNAME="$(getent passwd $USER | cut -d':' -f5)"
if [[ "$FULLNAME" == '' ]]; then
    export FULLNAME="$USER"
    export isAssumedFullName=y
else
    export FULLNAME="$(printf "$FULLNAME" | cut -d',' -f1)"
fi
if [[ ! -z "$MYNAME" ]]; then
    export FULLNAME="$MYNAME"
fi
if [[ -e $CONFDIR/myname ]]; then
    export FULLNAME="$(cat $CONFDIR/myname)"
fi
PRIVKEYPATH="$CONFDIR/mykeys/$FULLNAME"








### Library Functions
function _addContact() {
    echo "@name=$vSIGNER|@fp=$vFP|@sigkey=$vSIGKEY|@enckey=$vENCKEY" >> $CONFDIR/contacts.csv
}
function _getContactField() {
MATCHTABLE="@lstpos=1,@fdname=name,@firstc=7
@lstpos=2,@fdname=fp,@firstc=5
@lstpos=3,@fdname=sigkey,@firstc=9
@lstpos=4,@fdname=enckey,@firstc=9"
    BY_FIELDNAME="$1"
    BY_FIELDVAL="$2"
    GET_FIELDNAME="$3"
    MATCHED="$(echo "$MATCHTABLE" | grep "@fdname=$GET_FIELDNAME" | head -n1 )"
    FIELD_POS="$(echo "$MATCHED" | cut -d',' -f1 | cut -b9-)"
    FIRST_CHAR="$(echo "$MATCHED" | cut -d',' -f3 | cut -b9-)"
    grep "@$BY_FIELDNAME=$BY_FIELDVAL" $CONFDIR/contacts.csv | head -n1 | cut -d'|' -f"$FIELD_POS" | cut -b"$FIRST_CHAR"-
}






function _help() {
echo "tcrypt ($APPVER)

    Copyright (c) 2022 Neruthes <https://neruthes.xyz>.
    This script is a free software, licensed under GNU GPLv2.

    This script can be found at:
    https://github.com/neruthes/NDevShellRC/blob/master/bin/tcrypt


BASIC USAGE:
    tcrypt help                                     Print this help message.
    tcrypt keygen                                   Generate a keypair (ssh-ed25519).
    tcrypt i|interpret                              Try interpreting a message from stdin.
    tcrypt if|interpretfile FILE_PATH               Try interpreting a message from FIEL_PATH.

SIGNATURE:
    tcrypt cs|clearsign                             Sign a clear text file from stdin.
    tcrypt csf|clearsignfile FILE_PATH              Sign clear text file FILE_PATH.
    tcrypt vcs|verifyclearsign                      Verify clearsign from stdin.
    tcrypt vcsf|verifyclearsignfile FILE_PATH       Verify clearsign file FILE_PATH.

DATA MANAGEMENT:
    tcrypt ls|listcontacts                          Show the list of contacts.
    tcrypt addcontactfromclearsign                  Read clearsign msg from stdin; add signer as contact.
"
}

if [[ "$FULLNAME" != "$USER" ]]; then
    PREFERRED_KEYNAME="$FULLNAME"
else
    PREFERRED_KEYNAME="$USER"
fi


### Warn for keypair absence
if [[ ! -e "$PRIVKEYPATH" ]]; then
    if [[ "$TCRYPT_SPAWN" != y ]] && [[ "$1" != keygen ]]; then
        echo "[WARNING] You do not have a keypair '$PRIVKEYPATH' yet. Use 'tcrypt keygen' to create it."
    fi
fi

function _clearSession() {
    rm $TCryptSession.* 2>/dev/null
}

### Exit if absolutely no keypair
function _panicIfNoKeypair() {
    if [[ ! -e "$PRIVKEYPATH" ]]; then
        echo "[ERROR] Cannot find identity '$PRIVKEYPATH'. You need to run 'tcrypt keygen' before proceeding."
        exit 1
    fi
}

export TCRYPT_SPAWN=y
case "$1" in
    ### Normal usage entries
    help)
        _help
        ;;

    keygen)
        if [[ "$isAssumedFullName" == y ]]; then
            echo "Please specify your fullname:"
            printf '> '
            read FULLNAME
            export FULLNAME="$FULLNAME"
            PRIVKEYPATH="$CONFDIR/mykeys/$FULLNAME"
            echo "$FULLNAME" > $CONFDIR/myname
        fi
        if [[ -e "$PRIVKEYPATH" ]] && [[ "$2" != '-f' ]]; then
            echo "[ERROR] Identity '$PRIVKEYPATH' already exists! Append '-f' to overwrite."
            exit 1
        fi
        rm "$PRIVKEYPATH" "$PRIVKEYPATH".* 2>/dev/null
        echo "[INFO] Generating private key at '$PRIVKEYPATH'."

        ### Create signature key with OpenSSH
        ssh-keygen -t ed25519 -f "$PRIVKEYPATH.ed25519"
        cat "$PRIVKEYPATH.ed25519.pub" | cut -d' ' -f2 > "$PRIVKEYPATH.ed25519.pub.new"
        mv "$PRIVKEYPATH.ed25519.pub.new" "$PRIVKEYPATH.ed25519.pub"
        ### Create encryption key with OpenSSL
        openssl genpkey -out "$PRIVKEYPATH.x25519" -algorithm X25519
        openssl pkey -pubout -in "$PRIVKEYPATH.x25519" -out "$PRIVKEYPATH.x25519.pub"
        cat "$PRIVKEYPATH".* > "$PRIVKEYPATH"
        ;;

    i|interpret)
        cat /dev/stdin > $TCryptSession.stdin
        INITIAL_CHARS="$(head -n1 $TCryptSession.stdin)"
        ### Decide which operation to execute
        if [[ "$INITIAL_CHARS" == "#>MsgClearSig>"* ]]; then
            $tcrypt vcs < $TCryptSession.stdin
        fi
        _clearSession
        ;;

    if|interpretfile)
        INITIAL_CHARS="$(head -n1 "$2")"
        ### Decide which operation to execute
        if [[ "$INITIAL_CHARS" == "#>MsgClearSig>"* ]]; then
            $tcrypt vcsf "$2"
        fi
        ;;
    cs|clearsign)
        _panicIfNoKeypair
        cat /dev/stdin > $TCryptSession.stdin
        cat $TCryptSession.stdin | $tcrypt u_makeMsgBodyForClearSig | $tcrypt u_finalSign
        _clearSession
        ;;

    csf|clearsignfile)
        _panicIfNoKeypair
        cat "$2" | $tcrypt u_makeMsgBodyForClearSig | $tcrypt u_finalSign > "$2.signed.txt"
        echo "[INFO] Signed file '$2' and written to '$2.signed.txt'."
        ;;

    vcs|verifyclearsign)
        cat /dev/stdin > $TCryptSession.verifyclearsign
        $tcrypt u_verifyClearSign $TCryptSession.verifyclearsign
        _clearSession
        ;;

    vcsf|verifyclearsignfile)
        $tcrypt u_verifyClearSign $2
        ;;

    addcontactfromclearsign)
        cat /dev/stdin > $TCryptSession.clearSignMsg
        INPUTFN="$TCryptSession.clearSignMsg"
        ### Note: Contacts CSV fields = [ Name | SSH public key body | Signer fingerprint | X25519 encryption key ]
        vSIGNER="$(grep '#signer=' $INPUTFN | cut -b9-)"
        vSIGKEY="$(grep '#sigkey=' $INPUTFN | cut -b9-)"
        vFP="$(grep '#fingerprint=' $INPUTFN | cut -b14-)"
        vENCKEY="$(grep '#enckey=' $INPUTFN | cut -b9-)"
        if [[ "$(grep "$vSIGKEY" $CONFDIR/contacts.csv)" != '' ]]; then
            echo "[ERROR] The public key '$vSIGKEY' is already a contact, known as '$(_getContactField sigkey "$vSIGKEY" name)'."
            echo "        Edit the file '$CONFDIR/contacts.csv' if you have worries."
            exit 1
        fi
        echo "[INFO] Importing contact information:"
        echo "    Name:             $vSIGNER"
        echo "    Fingerprint:      $vFP"
        echo "    Signing Key:      $vSIGKEY"
        echo "    Encryption Key:   $vENCKEY"
        echo "@name=$vSIGNER|@fp=$vFP|@sigkey=$vSIGKEY|@enckey=$vENCKEY"
        vSIGNER=$vSIGNER vFP=$vFP vSIGKEY=$vSIGKEY vENCKEY=$vENCKEY _addContact
        # echo "@name=$vSIGNER|@fp=$vFP|@sigkey=$vSIGKEY|@enckey=$vENCKEY" >> $CONFDIR/contacts.csv
        _clearSession
        ;;
    ls|listcontacts)
        echo "[INFO] List of contacts:" >&2
            UUID="$(uuidgen v4)"
            CONTACTS_LIST="$(cat $CONFDIR/contacts.csv | cut -d'|' -f1-1,3-3 --output-delimiter='   ')"
            echo "$CONTACTS_LIST"
            # IFS=$'\n' for line in $CONTACTS_LIST; do
                # echo "  $line"
            # done
        ;;

    ### Reserved for internal calls
    u_makeMsgBodyForClearSig)
        cat /dev/stdin > $TCryptSession.u_makeMsgBodyForClearSig
        MSGTS="$(TZ=UTC date +%Y%m%d.%H%M%S)"
        SMALLHASH_1="$(sha256sum $TCryptSession.u_makeMsgBodyForClearSig | cut -b1-40)"
        SMALLHASH_2="$(echo "$MSGTS" | sha256sum | cut -b1-40)"
        SMALLHASH="$(echo "$SMALLHASH_1:$SMALLHASH_2" | sha256sum | cut -b1-16)"
        echo "#>MsgClearSig>$MSGTS>$SMALLHASH"
        echo "#signer=$FULLNAME"
        echo "#fingerprint=$($tcrypt u_calcSignerKeyFingerprint "$(cat "$PRIVKEYPATH.ed25519.pub")")"
        echo "#sigkey=$(cat "$PRIVKEYPATH.ed25519.pub")"
        echo "#enckey=$(cat "$PRIVKEYPATH.x25519.pub" | head -n2 | tail -n1)"
        echo "----------------------------------------------"
        echo ""
        cat $TCryptSession.u_makeMsgBodyForClearSig
        _clearSession
        ;;

    u_base64tohex)
        while read fileline; do
            echo $fileline | base64 -d -i | hexdump -v -e '/1 "%02x" ' >> /dev/stdout
            echo "" >> /dev/stdout
        done < /dev/stdin
        ;;

    u_finalSign)
        cat /dev/stdin > $TCryptSession.u_finalSign
        cat $TCryptSession.u_finalSign
        cat $TCryptSession.u_finalSign | ssh-keygen -Y sign -f "$PRIVKEYPATH.ed25519" -n MsgSigV1 > $TCryptSession.u_finalSign_out 2>/dev/null
        cat $TCryptSession.u_finalSign_out
        _clearSession
        ;;

    u_extractMsgBody)
        cat /dev/stdin > $TCryptSession.stdin
        LINECOUNT="$(wc -l $TCryptSession.stdin | cut -d' ' -f1)"
        LINECOUNT="$((LINECOUNT-6))"
        head -n"$LINECOUNT" $TCryptSession.stdin
        _clearSession
        ;;

    u_extractMsgSignature)
        cat /dev/stdin | tail -n6
        ;;

    u_calcSignerKeyFingerprint)
        # argv: Ed25519 public key (key body only, single-line)
        TMPSTR="$(printf "$2" | sha256sum | cut -b1-32)"
        printf -- "${TMPSTR^^}"
        ;;
        
    u_verifyClearSign)
        INPUTFN="$2"
        vSIGNER="$(grep '#signer=' $INPUTFN | cut -b9-)"
        vSIGKEY="$(grep '#sigkey=' $INPUTFN | cut -b9-)"
        echo "$vSIGNER ssh-ed25519 $vSIGKEY" > $TCryptSession.fakeSignersList
        
        cat $INPUTFN | $tcrypt u_extractMsgBody > $TCryptSession.msgBody
        cat $INPUTFN | $tcrypt u_extractMsgSignature > $TCryptSession.msgSig

        printf "\n===== INCOMING MESSAGE =====\n\n"
        cat $TCryptSession.msgBody
        printf "\n\n===== VERIFICATION RESULT =====\n\n"
        VERIFY_RESULT="$(ssh-keygen -Y verify -f $TCryptSession.fakeSignersList -I "$vSIGNER" -n MsgSigV1 -s $TCryptSession.msgSig < $TCryptSession.msgBody)"
        echo "[INFO] OpenSSH says: $VERIFY_RESULT"
        if [[ "$VERIFY_RESULT" == 'Good "MsgSigV1" signature for'* ]]; then
            echo "[INFO] Signature from '$vSIGKEY' is valid."
            ### Can we find the SigKey in contacts?
            if [[ "$(grep -v '^#' $CONFDIR/contacts.csv | grep "=$vSIGKEY")" != "" ]]; then
                ### Found the sigkey
                KEY_SAVED_NAME="$(_getContactField sigkey "$vSIGKEY" name)"
                CALCULATED_SAVED_FP="$($tcrypt u_calcSignerKeyFingerprint "$vSIGKEY")"
                EXTRACTED_SAVED_FP="$(grep '#fingerprint=' $INPUTFN | cut -b14-)"
                echo "[INFO] The signer is a contact, known as '$KEY_SAVED_NAME' (Fingerprint: $CALCULATED_SAVED_FP)."
                if [[ "$KEY_SAVED_NAME" != "$vSIGNER" ]]; then
                    echo "[WARNING] This contact is known as '$KEY_SAVED_NAME' and not '$vSIGNER'. Consider updating the saved name in '$CONFDIR/contacts.csv'."
                fi
            else
                echo "[INFO] BEWARE! Signer is not a contact! To add as contact, pipe the message to 'tcrypt addcontactfromclearsign'."
                ### Did we previously verify their message?
                GREP_RESULT="$(grep "$vSIGKEY" $CONFDIR/known_signers.csv)"
                if [[ "$GREP_RESULT" != "" ]]; then
                    MSG_COUNT="$(echo "$GREP_RESULT" | cut -d' ' -f4)"
                    CACHED_NAME="$(_getContactField sigkey "$vSIGKEY" name)"
                    echo "[INFO] We had verified $MSG_COUNT messages from this signer (previously known as '$CACHED_NAME') before."
                    ### Update the number
                    sed -i "s|$vSIGNER $vSIGKEY $MSG_COUNT|$vSIGNER $vSIGKEY $((MSG_COUNT+1))|" $CONFDIR/known_signers.csv
                else
                    ### This is the first message from them
                    ### Save into known_signers
                    echo "$vSIGNER $vSIGKEY 1" >> "$CONFDIR/known_signers.csv"
                fi
            fi
        else
            echo "[FATAL] The signature is invalid!"
        fi
        printf "\n\n"
        _clearSession
        ;;

    *)
        _help
        ;;

esac

