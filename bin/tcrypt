#!/bin/bash

APPVER="v0.1.4-pre1"

function debug() {
    printf ""
    echo ">>> debug: $1"
}

### Change CONFDIR by specifying an environment variable
if [[ -z "$CONFDIR" ]]; then
    CONFDIR="$HOME/.config/tcrypt"
fi

mkdir -p "$CONFDIR"/mykeys
### CSV delimiter is whitespace
touch "$CONFDIR/contacts.csv"
touch "$CONFDIR/known_signers.csv"     ### CSV format: "{NAME} ssh-ed25519 {SSHPUBKEY} {COUNT}"

export tcrypt="$(realpath $0)"
export TCryptSession="/tmp/tcryptUtilSession-$(uuidgen v4)"

export FULLNAME="$(getent passwd $USER | cut -d':' -f5)"
if [[ "$FULLNAME" == '' ]]; then
    export FULLNAME="$USER"
    export isAssumedFullName=y
else
    export FULLNAME="$(printf "$FULLNAME" | cut -d',' -f1)"
fi
if [[ ! -z "$MYNAME" ]]; then
    export FULLNAME="$MYNAME"
fi
if [[ -e $CONFDIR/myname ]]; then
    export FULLNAME="$(cat $CONFDIR/myname)"
fi
PRIVKEYPATH="$CONFDIR/mykeys/$FULLNAME"








### Library Functions
function _addContact() {
    echo "@name=$vSIGNER|@fp=$vFP|@sigkey=$vSIGKEY|@enckey=$vENCKEY" >> $CONFDIR/contacts.csv
}
function _getContactField() {
MATCHTABLE="@lstpos=1,@fdname=name,@firstc=7
@lstpos=2,@fdname=fp,@firstc=5
@lstpos=3,@fdname=sigkey,@firstc=9
@lstpos=4,@fdname=enckey,@firstc=9"
    BY_FIELDNAME="$1"
    BY_FIELDVAL="$2"
    GET_FIELDNAME="$3"
    MATCHED="$(echo "$MATCHTABLE" | grep "@fdname=$GET_FIELDNAME" | head -n1 )"
    FIELD_POS="$(echo "$MATCHED" | cut -d',' -f1 | cut -d= -f2-)"
    FIRST_CHAR="$(echo "$MATCHED" | cut -d',' -f3 | cut -d= -f2-)"
    grep "@$BY_FIELDNAME=$BY_FIELDVAL" $CONFDIR/contacts.csv | head -n1 | cut -d'|' -f"$FIELD_POS" | cut -c"$FIRST_CHAR"-
}
function u_calcSignerKeyFingerprint() {
    # $1: Ed25519 public key (key body only, single-line)
    TMPSTR="$( printf "$1" | sha256sum | cut -c1-32 )"
    printf -- "${TMPSTR^^}"
}
function u_calcSignerKeyPawprint() {
    # $1: Ed25519 public key (key body only, single-line)
    TMPSTR="$( printf "$1" | sha512sum | cut -d' ' -f1 | xxd -r -p | base64 | tr '\n' '|' | sed 's/[|=]//g' )"
    printf -- "${TMPSTR}"
}
function u_verifyClearSign() {
    INPUTFN="$1"
    vSIGNER="$(grep '#signer=' $INPUTFN | cut -d= -f2-)"
    vSIGKEY="$(grep '#sigkey=' $INPUTFN | cut -d= -f2-)"
    echo "$vSIGNER ssh-ed25519 $vSIGKEY" > $TCryptSession.fakeSignersList
    
    cat $INPUTFN | $tcrypt u_extractMsgBody > $TCryptSession.msgBody
    cat $INPUTFN | $tcrypt u_extractMsgSignature > $TCryptSession.msgSig

    printf "\n===== INCOMING MESSAGE =====\n\n"
    cat $TCryptSession.msgBody
    printf "\n\n===== VERIFICATION RESULT =====\n\n"
    VERIFY_RESULT="$(ssh-keygen -Y verify -f $TCryptSession.fakeSignersList -I "$vSIGNER" -n MsgSigV1 -s $TCryptSession.msgSig < $TCryptSession.msgBody)"
    echo "[INFO] OpenSSH says: $VERIFY_RESULT"
    if [[ "$VERIFY_RESULT" == 'Good "MsgSigV1" signature for'* ]]; then
        echo "[INFO] Signature from '$vSIGKEY' is valid."
        ### Can we find the SigKey in contacts?
        if [[ "$(grep -v '^#' $CONFDIR/contacts.csv | grep "=$vSIGKEY")" != "" ]]; then
            ### Found the sigkey
            KEY_SAVED_NAME="$(_getContactField sigkey "$vSIGKEY" name)"
            CALCULATED_SAVED_FP="$(u_calcSignerKeyFingerprint "$vSIGKEY")"
            EXTRACTED_SAVED_FP="$(grep '#fingerprint=' $INPUTFN | cut -c14-)"
            echo "[INFO] The signer is a contact, known as '$KEY_SAVED_NAME' (Fingerprint: $CALCULATED_SAVED_FP)."
            if [[ "$KEY_SAVED_NAME" != "$vSIGNER" ]]; then
                echo "[WARNING] This contact is known as '$KEY_SAVED_NAME' and not '$vSIGNER'. Consider updating the saved name in '$CONFDIR/contacts.csv'."
            fi
        else
            echo "[INFO] BEWARE! Signer is not a contact! To add as contact, pipe the message to 'tcrypt addcontactfromclearsign'."
            ### Did we previously verify their message?
            GREP_RESULT="$(grep "$vSIGKEY" $CONFDIR/known_signers.csv)"
            if [[ "$GREP_RESULT" != "" ]]; then
                MSG_COUNT="$(echo "$GREP_RESULT" | cut -d' ' -f4)"
                CACHED_NAME="$(_getContactField sigkey "$vSIGKEY" name)"
                echo "[INFO] We had verified $MSG_COUNT messages from this signer (previously known as '$CACHED_NAME') before."
                ### Update the number
                sed -i "s|$vSIGNER $vSIGKEY $MSG_COUNT|$vSIGNER $vSIGKEY $((MSG_COUNT+1))|" $CONFDIR/known_signers.csv
            else
                ### This is the first message from them
                ### Save into known_signers
                echo "$vSIGNER $vSIGKEY 1" >> "$CONFDIR/known_signers.csv"
            fi
        fi
    else
        echo "[FATAL] The signature is invalid!"
    fi
    printf "\n\n"
    _clearSession
}
function u_base64tohex() {
    INPUTFN="$1"
    OUTPUTFN="$2"
    while read fileline; do
        echo $fileline | base64 -d -i | hexdump -v -e '/1 "%02x" ' >> "$OUTPUTFN"
        echo "" >> "$OUTPUTFN"
    done < "$INPUTFN"
}
function _encEcdhMkRskey() {
    PUBKEY="$1"
    PRIVKEY_PATH="$2"
    echo "-----BEGIN PUBLIC KEY-----
$PUBKEY
-----END PUBLIC KEY-----" > $TCryptSession.PUBKEY_PATH.$COUNT

    openssl pkeyutl -derive -inkey $PRIVKEY_PATH -peerkey $TCryptSession.PUBKEY_PATH.$COUNT -out $TCryptSession.shsec.$COUNT
    SHSEC_VAL="$( cat $TCryptSession.shsec.$COUNT | hexdump -v -e '/1 "%02x" ' )"
    # echo "debug: Recipient-specific shared secret (shsec) for '$( _getContactField enckey "$PUBKEY" name )': '$SHSEC_VAL'" >&2

    openssl enc -aes-256-cbc -nosalt -e -in $TCryptSession.msgkey -out $TCryptSession.rskeyBody.$COUNT -K "$SHSEC_VAL" -iv "$MSGIV_VAL"
    rskeyBody="$(base64 $TCryptSession.rskeyBody.$COUNT)"
    echo "$rskeyBody"
}
function u_ecdhEncryptFile() {
    ### Hybrid ECDH

    MSGTS="$(TZ=UTC date +%Y%m%d.%H%M%S)"
    SMALLHASH_1="$(sha256sum $TCryptSession.stdin | cut -c1-40)"
    SMALLHASH_2="$(echo "$MSGTS" | sha256sum | cut -c1-40)"
    SMALLHASH="$(echo "$SMALLHASH_1:$SMALLHASH_2" | sha256sum | cut -c1-16)"

    ### Generate symmetric message key (msgkey, msgiv)
    dd if=/dev/urandom of=$TCryptSession.msgkey bs=32 count=1 2>/dev/null
    dd if=/dev/urandom of=$TCryptSession.msgiv bs=16 count=1 2>/dev/null
    MSGKEY_VAL="$(hexdump -v -e '/1 "%02x" ' $TCryptSession.msgkey)"
    MSGIV_VAL="$(hexdump -v -e '/1 "%02x" ' $TCryptSession.msgiv)"
    # echo "debug: msgiv=$MSGIV_VAL" >&2
    # echo "debug: msgkey=$(base64 $TCryptSession.msgkey)" >&2

    ### Generate ephemeral keypair
    openssl genpkey -algorithm X25519 -out "$TCryptSession.ephemeral.pem"
    openssl pkey -pubout -in "$TCryptSession.ephemeral.pem" -out "$TCryptSession.ephemeral.pub"
    EPHE_PUB="$(head -n2 "$TCryptSession.ephemeral.pub" | tail -n1)"
    # echo "debug: EPHE_PUB=$EPHE_PUB" >&2

    ### Generate recipient-specific key (rskey) list
    COUNT=0
    for vFP in $(echo "$FP_LIST" | sed 's|,| |g'); do
        # echo "$fp"
        ENCKEY="$(_getContactField fp "$vFP" enckey)"
        # echo "#rskey=$(_encEcdhMkRskey "$fp" "$MSGKEY_VAL")" >> $TCryptSession.rskeyList
        echo "#rskey=$(_encEcdhMkRskey "$ENCKEY" "$TCryptSession.ephemeral.pem")" >> $TCryptSession.rskeyList
        COUNT="$((COUNT+1))"
    done

    ### Encrypt message
    openssl enc -aes-256-cbc -nosalt -e -in $TCryptSession.stdin -out $TCryptSession.msg.enc -K "$MSGKEY_VAL" -iv "$MSGIV_VAL"

    ### Final output
    echo "#>MsgEnc>$MSGTS>$SMALLHASH" > $TCryptSession.stdout
    echo "#ephepub=$EPHE_PUB" >> $TCryptSession.stdout
    # echo "#msgkey=$MSGKEY_VAL" >> $TCryptSession.stdout       # Debug only; should not include in the payload
    echo "#aesiv=$MSGIV_VAL" >> $TCryptSession.stdout
    cat $TCryptSession.rskeyList >> $TCryptSession.stdout
    echo "-------------------------------" >> $TCryptSession.stdout
    base64 $TCryptSession.msg.enc >> $TCryptSession.stdout

    cat $TCryptSession.stdout
    # exit 0
}
function u_ecdhDecryptFile() {
    ### Get symEncBody (removing the header)
    ENDHEADER=n
    HLINES=1
    while [[ $ENDHEADER == n ]]; do
        if [[ "$(sed "${HLINES}q;d" "$TCryptSession.stdin" | cut -c1)" == "#" ]]; then
            ### Continue
            HLINES="$((HLINES+1))"
        else
            ### Break
            ENDHEADER=y
        fi
        if [[ $HLINES == "30" ]]; then
            ### Break anyway when reaching a threshold
            ENDHEADER=y
        fi
    done
    tail -n +$((HLINES+1)) "$TCryptSession.stdin"  | base64 -d > $TCryptSession.symEncBody

    ### Get ephepub
    # grep '#msgkey=' $TCryptSession.stdin >&2        # Debug only; will not find msgkey in the payload
    # grep '#aesiv=' $TCryptSession.stdin >&2
    vEPHEPUB="$(grep '#ephepub=' $TCryptSession.stdin | cut -d'=' -f2-)"
    MSGIV_VAL="$(grep '#aesiv=' $TCryptSession.stdin | cut -d'=' -f2-)"
    # echo "debug: vEPHEPUB=$vEPHEPUB" >&2
    # echo "debug: MSGIV_VAL=$MSGIV_VAL" >&2

    echo "-----BEGIN PUBLIC KEY-----
$vEPHEPUB
-----END PUBLIC KEY-----" > $TCryptSession.ephepub

    ### Derive shared secret (shsec)
    SHSEC_VAL="$( openssl pkeyutl -derive -inkey $PRIVKEYPATH.x25519 -peerkey $TCryptSession.ephepub -out /dev/stdout | hexdump -v -e '/1 "%02x" ' )"
    # echo "debug: SHSEC_VAL=$SHSEC_VAL" >&2
    ### Try decrypting any rskey with shsec
    SUCCESS_ITR=null
    COUNT=0
    for rskeyBody in $(grep '#rskey=' $TCryptSession.stdin | cut -d'=' -f2-); do
        echo "$rskeyBody" | base64 -d > $TCryptSession.rskeyBody.$COUNT
        openssl enc -aes-256-cbc -nosalt -d -in $TCryptSession.rskeyBody.$COUNT -out $TCryptSession.rskeyBody.$COUNT.out -K "$SHSEC_VAL" -iv "$MSGIV_VAL" 2>/dev/null
        if [[ $? == 0 ]]; then
            SUCCESS_ITR=$COUNT
        # else
            # echo "debug: Decryption failed at $COUNT" >&2
        fi
        COUNT="$((COUNT+1))"
    done
    if [[ "$SUCCESS_ITR" == null ]]; then
        echo "[ERROR] Cannot decrypt the payload. Did the sender really encrypt for you?"
        echo "        Or try using a different identity by specifying MYNAME environment variable."
        return 1
    else
        # echo "debug: SUCCESS_ITR=$SUCCESS_ITR" >&2
        MSGKEY_VAL="$(hexdump -v -e '/1 "%02x" ' $TCryptSession.rskeyBody.$SUCCESS_ITR.out)"
        # echo "debug: MSGKEY_VAL=$MSGKEY_VAL" >&2

        ### Now decrypt the message body with MSGKEY_VAL and MSGKIV_VAL
        openssl enc -aes-256-cbc -nosalt -d -in $TCryptSession.symEncBody -out $TCryptSession.symEncBody.out -K "$MSGKEY_VAL" -iv "$MSGIV_VAL"
        cat $TCryptSession.symEncBody.out
    fi
}





function _help() {
echo "tcrypt ($APPVER)

    Copyright (c) 2022 Neruthes <https://neruthes.xyz>.
    This script is a free software, licensed under GNU GPLv2.

    This script can be found at:
    https://github.com/neruthes/NDevShellRC/blob/master/bin/tcrypt


BASIC USAGE:
    tcrypt help                                     Print this help message.
    tcrypt keygen                                   Generate an identity (signature/encryption keypairs).
    tcrypt i|interpret                              Try interpreting a message from stdin.
    tcrypt if|interpretfile FILE_PATH               Try interpreting a message from FIEL_PATH.

SIGNATURE:
    tcrypt cs|clearsign                             Sign a clear text file from stdin.
    tcrypt csf|clearsignfile FILE_PATH              Sign clear text file FILE_PATH.
    tcrypt vcs|verifyclearsign                      Verify clearsign from stdin.
    tcrypt vcsf|verifyclearsignfile FILE_PATH       Verify clearsign file FILE_PATH.

SIGNATURE:
    tcrypt e|encrypt FP_LIST                        Encrypt a file for listed recipients.
    tcrypt ef|encryptfile FP_LIST FILE_PATH         Encrypt file FILE_PATH for listed recipients.
    tcrypt d|decrypt                                Decrypt from stdin.
    tcrypt df|decryptfile FILE_PATH                 Decrypt file FILE_PATH.

    Notes:
        - FP_LIST is a comma-delimited list of fingerprints.

DATA MANAGEMENT:
    tcrypt ls|listcontacts                          Show the list of contacts.
    tcrypt ic|inspectcontact FINGERPRINT            Inspect contact info.
    tcrypt addcontactfromclearsign                  Read clearsign msg from stdin; add signer as contact.
"
}

if [[ "$FULLNAME" != "$USER" ]]; then
    PREFERRED_KEYNAME="$FULLNAME"
else
    PREFERRED_KEYNAME="$USER"
fi


### Warn for keypair absence
if [[ ! -e "$PRIVKEYPATH" ]]; then
    if [[ "$TCRYPT_SPAWN" != y ]] && [[ "$1" != keygen ]]; then
        echo "[WARNING] You do not have a keypair '$PRIVKEYPATH' yet. Use 'tcrypt keygen' to create it."
    fi
fi

function _clearSession() {
    rm $TCryptSession.* 2>/dev/null
}

### Exit if absolutely no keypair
function _panicIfNoKeypair() {
    if [[ ! -e "$PRIVKEYPATH" ]]; then
        echo "[ERROR] Cannot find identity '$PRIVKEYPATH'. You need to run 'tcrypt keygen' before proceeding."
        exit 1
    fi
}

export TCRYPT_SPAWN=y
case "$1" in
    ### Normal usage entries
    help)
        _help
        ;;

    keygen)
        if [[ "$isAssumedFullName" == y ]]; then
            echo "Please specify your fullname:"
            printf '> '
            read FULLNAME
            export FULLNAME="$FULLNAME"
            PRIVKEYPATH="$CONFDIR/mykeys/$FULLNAME"
            echo "$FULLNAME" > $CONFDIR/myname
        fi
        if [[ -e "$PRIVKEYPATH" ]] && [[ "$2" != '-f' ]]; then
            echo "[ERROR] Identity '$PRIVKEYPATH' already exists! Append '-f' to overwrite."
            exit 1
        fi
        rm "$PRIVKEYPATH" "$PRIVKEYPATH".* 2>/dev/null
        echo "[INFO] Generating private key at '$PRIVKEYPATH'."

        ### Create signature key with OpenSSH
        ssh-keygen -t ed25519 -f "$PRIVKEYPATH.ed25519"
        cat "$PRIVKEYPATH.ed25519.pub" | cut -d' ' -f2 > "$PRIVKEYPATH.ed25519.pub.new"
        mv "$PRIVKEYPATH.ed25519.pub.new" "$PRIVKEYPATH.ed25519.pub"
        ### Create encryption key with OpenSSL
        openssl genpkey -out "$PRIVKEYPATH.x25519" -algorithm X25519
        openssl pkey -pubout -in "$PRIVKEYPATH.x25519" -out "$PRIVKEYPATH.x25519.pub"
        cat "$PRIVKEYPATH".* > "$PRIVKEYPATH"
        ;;

    i|interpret)
        cat /dev/stdin > $TCryptSession.stdin
        PAYLOAD_TYPE_MARK="$(head -n1 $TCryptSession.stdin | cut -d'>' -f2)"
        ### Decide which operation to execute
        if [[ "$PAYLOAD_TYPE_MARK" == "MsgClearSig" ]]; then
            $tcrypt vcs < $TCryptSession.stdin
        fi
        _clearSession
        ;;

    if|interpretfile)
        PAYLOAD_TYPE_MARK="$(head -n1 $TCryptSession.stdin | cut -d'>' -f2)"
        ### Decide which operation to execute
        if [[ "$PAYLOAD_TYPE_MARK" == "MsgClearSig" ]]; then
            $tcrypt vcsf "$2"
        fi
        ;;

    cs|clearsign)
        _panicIfNoKeypair
        cat /dev/stdin > $TCryptSession.stdin
        cat $TCryptSession.stdin | $tcrypt u_makeMsgBodyForClearSig | $tcrypt u_finalSign
        _clearSession
        ;;

    csf|clearsignfile)
        _panicIfNoKeypair
        cat "$2" | $tcrypt u_makeMsgBodyForClearSig | $tcrypt u_finalSign > "$2.signed.txt"
        echo "[INFO] Signed file '$2' and written to '$2.signed.txt'." >&2
        ;;

    vcs|verifyclearsign)
        cat /dev/stdin > $TCryptSession.verifyclearsign
        u_verifyClearSign $TCryptSession.verifyclearsign
        _clearSession
        ;;

    vcsf|verifyclearsignfile)
        u_verifyClearSign $2
        ;;

    e|encrypt)
        if [[ -z $2 ]]; then
            _help | grep 'e|encrypt'
            exit 0
        fi
        cat /dev/stdin > $TCryptSession.stdin
        FP_LIST="$2" u_ecdhEncryptFile
        _clearSession
        ;;

    ef|encryptfile)
        if [[ -z $3 ]]; then
            _help | grep 'ef|encryptfile'
            exit 0
        fi
        cat "$3" > $TCryptSession.stdin
        FP_LIST="$2" u_ecdhEncryptFile > $3.enc
        _clearSession
        ;;

    d|decrypt)
        cat /dev/stdin > $TCryptSession.stdin
        u_ecdhDecryptFile
        _clearSession
        ;;

    df|decryptfile)
        if [[ -z $2 ]]; then
            _help | grep 'e|encrypt'
            exit 0
        fi
        cat "$2" > $TCryptSession.stdin
        u_ecdhDecryptFile
        _clearSession
        ;;

    accs|addcontactfromclearsign)
        cat /dev/stdin > $TCryptSession.clearSignMsg
        INPUTFN="$TCryptSession.clearSignMsg"
        ### Note: Contacts CSV fields = [ Name | SSH public key body | Signer fingerprint | X25519 encryption key ]
        vSIGNER="$(grep '#signer=' $INPUTFN | cut -d'=' -f2-)"
        vSIGKEY="$(grep '#sigkey=' $INPUTFN | cut -d'=' -f2-)"
        vFP="$(grep '#fingerprint=' $INPUTFN | cut -d'=' -f2-)"
        vENCKEY="$(grep '#enckey=' $INPUTFN | cut -d'=' -f2-)"
        if [[ "$(grep "$vSIGKEY" $CONFDIR/contacts.csv)" != '' ]]; then
            echo "[ERROR] The public key '$vSIGKEY' is already a contact, known as '$(_getContactField sigkey "$vSIGKEY" name)'."
            echo "        Edit the file '$CONFDIR/contacts.csv' if you have worries."
            exit 1
        fi
        echo "[INFO] Importing contact information:"
        echo "    Name:             $vSIGNER"
        echo "    Fingerprint:      $vFP"
        echo "    Signing Key:      $vSIGKEY"
        echo "    Encryption Key:   $vENCKEY"
        echo "@name=$vSIGNER|@fp=$vFP|@sigkey=$vSIGKEY|@enckey=$vENCKEY"
        vSIGNER=$vSIGNER vFP=$vFP vSIGKEY=$vSIGKEY vENCKEY=$vENCKEY _addContact
        echo "@name=$vSIGNER|@fp=$vFP|@sigkey=$vSIGKEY|@enckey=$vENCKEY" >> $CONFDIR/contacts.csv
        _clearSession
        ;;
    ls|listcontacts)
        echo "[INFO] List of contacts:" >&2
        NAMES_LIST="$(cat $CONFDIR/contacts.csv | cut -d'|' -f1 | cut -d'=' -f2-)"
        IFS=$'\n'
        SPACELINE='                              '
        echo "  Name                                | Fingerprint"
        echo "  ------------------------------------+---------------------------------"
        for CONTACT_NAME in $NAMES_LIST; do
            # IFS=' '
            vFP="$(_getContactField name "$CONTACT_NAME" fp)"
            echo "  $CONTACT_NAME     ${SPACELINE:${#CONTACT_NAME}} | $vFP"
        done
        ;;

    ic|inspectcontact)
        if [[ -z $2 ]]; then
            echo "[ERROR] No fingerprint specified."
            exit 0
        fi
        echo "[INFO] Inspecting contact by fingerprint '$2':" >&2
        # cat $CONFDIR/contacts.csv | grep "@fp=$2"
        # cat $CONFDIR/contacts.csv | cut -d'|' -f1-1,2-2 --output-delimiter='   ' | sed 's/=/= /g'
        echo ""
        echo "Name:         $(_getContactField fp "$2" name)"
        echo "Fingerprint:  $(_getContactField fp "$2" fp)"
        echo "sigkey:       $(_getContactField fp "$2" sigkey)"
        echo "enckey:       $(_getContactField fp "$2" enckey)"
        # CONTACTS_LIST="$( cat $CONFDIR/contacts.csv | cut -d'|' -f1-1,2-2 --output-delimiter='   ' | sed 's/=/= /g' )"
        # echo "$CONTACTS_LIST"
        ;;

    ### Reserved for internal recursive calls
    u_makeMsgBodyForClearSig)
        cat /dev/stdin > $TCryptSession.u_makeMsgBodyForClearSig
        MSGTS="$(TZ=UTC date +%Y%m%d.%H%M%S)"
        SMALLHASH_1="$(sha256sum $TCryptSession.u_makeMsgBodyForClearSig | cut -c1-40)"
        SMALLHASH_2="$(echo "$MSGTS" | sha256sum | cut -c1-40)"
        SMALLHASH="$(echo "$SMALLHASH_1:$SMALLHASH_2" | sha256sum | cut -c1-16)"
        echo "#>MsgClearSig>$MSGTS>$SMALLHASH"
        echo "#signer=$FULLNAME"
        echo "#fingerprint=$(u_calcSignerKeyFingerprint "$(cat "$PRIVKEYPATH.ed25519.pub")")"
        echo "#pawprint=$(u_calcSignerKeyPawprint "$(cat "$PRIVKEYPATH.ed25519.pub")")"
        echo "#sigkey=$(cat "$PRIVKEYPATH.ed25519.pub")"
        echo "#enckey=$(cat "$PRIVKEYPATH.x25519.pub" | head -n2 | tail -n1)"
        echo "----------------------------------------------"
        echo ""
        cat $TCryptSession.u_makeMsgBodyForClearSig
        _clearSession
        ;;

    u_finalSign)
        cat /dev/stdin > $TCryptSession.u_finalSign
        cat $TCryptSession.u_finalSign
        cat $TCryptSession.u_finalSign | ssh-keygen -Y sign -f "$PRIVKEYPATH.ed25519" -n MsgSigV1 > $TCryptSession.u_finalSign_out 2>/dev/null
        cat $TCryptSession.u_finalSign_out
        _clearSession
        ;;

    u_extractMsgBody)
        cat /dev/stdin > $TCryptSession.stdin
        LINECOUNT="$(wc -l $TCryptSession.stdin | cut -d' ' -f1)"
        LINECOUNT="$((LINECOUNT-6))"
        head -n"$LINECOUNT" $TCryptSession.stdin
        _clearSession
        ;;

    u_extractMsgSignature)
        cat /dev/stdin | tail -n6
        ;;

    *)
        _help
        ;;

esac

